<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>fts vs dirent vs ftw | Prince Addo's /blog</title><meta name=keywords content="linux-programming"><meta name=description content="A comparison on the fts.h, dirent.h, and ftw.h libraries"><meta name=author content="Prince Addo"><link rel=canonical href=http://127.0.0.1:3000/post/fts-vs-dirent-vs-ftw/><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><link rel=stylesheet href=css/index.css><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://127.0.0.1:3000/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://127.0.0.1:3000/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://127.0.0.1:3000/favicon-32x32.png><link rel=apple-touch-icon href=http://127.0.0.1:3000/apple-touch-icon.png><link rel=mask-icon href=http://127.0.0.1:3000/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="fts vs dirent vs ftw"><meta property="og:description" content="A comparison on the fts.h, dirent.h, and ftw.h libraries"><meta property="og:type" content="article"><meta property="og:url" content="http://127.0.0.1:3000/post/fts-vs-dirent-vs-ftw/"><meta property="og:image" content="http://127.0.0.1:3000/assets/letter_p.jpg"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-01-13T12:47:29-05:00"><meta property="article:modified_time" content="2023-01-13T12:47:29-05:00"><meta property="og:site_name" content="Prince Addo's /blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://127.0.0.1:3000/assets/letter_p.jpg"><meta name=twitter:title content="fts vs dirent vs ftw"><meta name=twitter:description content="A comparison on the fts.h, dirent.h, and ftw.h libraries"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://127.0.0.1:3000/post/"},{"@type":"ListItem","position":3,"name":"fts vs dirent vs ftw","item":"http://127.0.0.1:3000/post/fts-vs-dirent-vs-ftw/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"fts vs dirent vs ftw","name":"fts vs dirent vs ftw","description":"A comparison on the fts.h, dirent.h, and ftw.h libraries","keywords":["linux-programming"],"articleBody":"fts.h, dirent.h and ftw.h are distinct libraries, but what they all have in common is that they can be used to do the important job of traversing the Linux directory tree. In this article, the pros and cons of using one of these libraries over the other will be weighed so you can make a more informed decision when choosing one of these libraries.\nftw.h description ftw.h is a library that defines two key functions:\n#include int ftw(const char *dirpath, int (*fn) (const char *fpath, const struct *sb, int typeflag), int nopenfd ); // returns 0 on success, and -1 if an error occured. int nftw(const char *dirpath, int (*fn) (const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf), int nopenfd, int flags ); // returns 0 on success, and -1 if an error occured. ftw was obsoleted by POSIX.1-2008, so we will not be discussing that function. nftw is a function that walks through the entire directory tree, until the leaf, using pre-order traversal(by default). The function takes in the path of the where the function will start, dirpath, a function that matches the prototype, fn, the number of file discriptors the function is allowed to have open at one time, nopenfd, and optional flags, flags.\nThe user defined function input,\tfn, is what nftw will call every time it reaches a new file in the directory tree. fn takes in as input a string containing the path of the current file, fpath, a stat struct, sb, flags, typeflag, and a FWT struct,\tftwbuf. The stat struct is the same that is returned by calling the statfunction. It is defined as\nstruct stat { dev_t st_dev; /* ID of device containing file */ ino_t st_ino; /* inode number */ mode_t st_mode; /* protection */ nlink_t st_nlink; /* number of hard links */ uid_t st_uid; /* user ID of owner */ gid_t st_gid; /* group ID of owner */ dev_t st_rdev; /* device ID (if special file) */ off_t st_size; /* total size, in bytes */ blksize_t st_blksize; /* blocksize for file system I/O */ blkcnt_t st_blocks; /* number of 512B blocks allocated */ time_t st_atime; /* time of last access */ time_t st_mtime; /* time of last modification */ time_t st_ctime; /* time of last status change */ }; typeflag could be any one of these values:\nFTW_F := fpath is a regular file.\nFTW_D | FTW_DP := fpath is a directory.\nFTW_SL | FTW_SLN := fpath is a symbolic link.\nFTW_DNR := fpath is a directory which cannot be read.\nFTW_NS := The stat function call failed on fpath.\nftwbuf is a FTW struct defined as\nstruct FTW { int base; int level; }; where base is the offset of the filename in fpath and level is the depth of fpath in the directory path, relative to the specified root, which has a level of 0.\nTwo important\tflags that you should know about are\nFTW_DEPTH := when set, the function changes the traversal from pre-order to a post-order traversal.\nFTW_PHYS := when set, the function does not follow symbolic links when they are encountered.\nFor a more in-depth description of ftw.h read the man page.\nexample This is an example of using nftw to count the number of directories in the current path.\n#include #include #include #include int directoryN = 0; int directoryCounter(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf) { if((typeflag == FTW_D || typeflag == FTW_DP) \u0026\u0026 !strcmp(fpath, \".\") \u0026\u0026 !strcmp(fpath, \"..\")) directoryN++; return 0; } int main(void){ int flags = FTW_PHYS | FTW_DEPTH; if(nftw(\".\", directoryCounter, 20, flags) == -1) { perror(\"nftw\"); return 1; } printf(\"There are %u directories in the current directory\\n\", directoryN); return 0; } pros The biggest advantage of using nftw is its ease of use; with e simple function and a couple of flags, you can have a Linux directory tree traverser up and running. Another advantage is the simplicity. The fn function provides you with basically all the detail about a particular file, so you can easily use that information to make a decision. Overall,\tthe ftw library allows you to easily develop a simple program that traverses Linux directory tree.\ncons The nftw, and especially the ftw, function is too simple for a more complex program. For example, if you want to create a abstract representation of the Linux directory tree in memory it will be, at least, non-trivial and probably impossible. This is because the nftw function abstracts away the traversal and only offers a linear representation of the it.\ndirent.h description The key functions for dirent.h are:\n#include #include DIR *opendir(const char *name); // returns NULL if an error occurs and sets errno DIR *fdopendir(int fd); // returns NULL if an error occurs and sets errno struct dirent *readdir(DIR *dirp); // returns NULL if an error occurs and sets errno int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result); // returns 0 on success and a positive error number if an error occurs void seekdir(DIR *dirp, long offset); long telldir(DIR *dirp); // returns -1 on if an error occurs and sets errno int closedir(DIR *dirp); // returns 0 on success. On error, returns -1 and sets errno The dirent library follows the familiar open, read, close pattern that is used in read only files and the functions also match such purposes. opendir and fdopendir both open a new DIR, they use the path of the root folder and the file file descriptor or the directory, respectively. DIR is the central component of the dirent library. Similar to FILE, you can read it by passing it to a function, but unlike FILE you cannot write directly to it.\nBoth the\treaddir and\treaddir_r function read DIR; the\treaddir function returns a dirent structure while the readdir_r takes in an existing dirent structure, entry, and another dirent structure, result and stores the current directory entry in entry and the next one in result.\nFinally, seekdir and telldir are used to deposition DIR and closedir is used to close it.\nThe dirent structure, the most important structure in the dirent structure, is described as\nstruct dirent { ino_t d_ino; /* inode number */ off_t d_off; /* offset to the next dirent */ unsigned short d_reclen; /* length of this record */ unsigned char d_type; /* type of file; not supported by all file system types */ char d_name[256]; /* filename */ }; For a more in-depth description of dirent.h read the source code.\nexample Another implementation of the number of directories in the current path.\n#include #include #include #include int directoryN = 0; void directoryCounter(DIR *root, const char *root_path) { struct dirent *p; while((p = readdir(root)) != NULL){ if(!strcmp(p-\u003ed_name, \".\") \u0026\u0026 !strcmp(p-\u003ed_name, \"..\")) continue; if(p-\u003ed_type == DT_DIR){ directoryN++; char *full_path = (char *)malloc(strlen(root_path) + strlen(p-\u003ed_name) + 1); strcpy(full_path, root_path); strcat(full_path, p-\u003ed_name); strcat(full_path, \"/\"); DIR *curr; if((curr = opendir(full_path)) == NULL){ perror(\"\"); exit(1); } directroyCounter(curr, full_path); } } } int main(void) { DIR *curr; const char *root_path = \"./\"; if((curr = opendir(root_path)) == NULL){ perror(\"\"); exit(1); } directoryCounter(curr, root_path); printf(\"There are %u directories in the current directory\\n\", directoryN); return 0; } pros dirent.h gives you more control over the method in which you execute the program. This means that you can tailor the code to do what you need it to do and possibly achieve a faster running time because of that. It also allows you to create more complex algorithm by giving you the choice to go up or down the tree at any moment.\ncons The increased flexibility leads to increased complexity. Not only will you have to execute several functions provided by dirent.h, but you will also have to use other functions from other libraries(or even worst, make your own) to create a complete program. This is due partly because the lack of information in the dirent structure.\nfts.h description The key functions in fts.h are:\nFTS *fts_open(char * const *path_argv, int options, int (*compar)(const FTSENT **, const FTSENT **)); FTSENT *fts_read(FTS *ftsp); int fts_close(FTS *ftsp); The fts library has similar interfaces as dirent.h. fts_open create a new FTS which is analogous to DIR. fts_read reads the directory in preorder(by default) or postorder depending on the option you gave to the\tfts_open function.\nThe FTSENT structure is what stores all the major information about a particular file. The structure is described as:\ntypedef struct _ftsent { unsigned short fts_info; /* flags for FTSENT structure */ char *fts_accpath; /* access path */ char *fts_path; /* root path */ short fts_pathlen; /* strlen(fts_path) */ char *fts_name; /* filename */ short fts_namelen; /* strlen(fts_name) */ short fts_level; /* depth (-1 to N) */ int fts_errno; /* file errno */ long fts_number; /* local numeric value */ void *fts_pointer; /* local address value */ struct ftsent *fts_parent; /* parent directory */ struct ftsent *fts_link; /* next file structure */ struct ftsent *fts_cycle; /* cycle structure */ struct stat *fts_statp; /* stat(2) information */ } FTSENT; For more information on fts.h check out the man page\nexample Yet another implementation of the number of directories in the current path.\n#include #include #include int directoryN = 0; int main(void){ FTS *op; FTSENT *curr; char *root_path = {\"./\", NULL }; if((op = fts_open(root_path, FTS_NOCHDIR | FTS_PHYSICAL | FTS_XDEV, NULL)) == NULL){ perror(\"\"); exit(1); } while((curr = fts_read(op)) != NULL){ if(S_ISDIR(curr-\u003efts_statp-\u003emode)){ directoryN++; } } printf(\"There are %u directories in the current directory\\n\", directoryN); return 0; } pros fts.h allows you to create directory tree traversal quickly and FTSENT provides you with a lot of useful information about the current file.\ncons The library is relatively obscure and at times hard to understand. It also suffers from the same problem as ftw.h, namely, it is difficult to build more complex applications; but my intuition tell me that fts.h allows more complexity than ftw.h because you’re looping while you read.\nConclusion After examining and experimenting with the various libraries, the choice between fts.h, dirent.h and ftw.h depends on you’re particular application and its complexity. For example, if you’re building a ls(1) clone, than either ftw.h or fts.h would be a great choice because that command doesn’t require any complicated traversal or to create a another structure. If I were to list the libraries by order of how complex they allow you to build you’re application, it would be: dirent.h, fts.h, ftw.h; with dirent.h allowing you to build the most complex applications.\nSo, if you’re deciding which library to use, first think about how complex you’re application will be and how much control of the directory tree traversal you want, and then make your choice. And if you want complete control, you can go as low as using the read and getdents system calls.\n","wordCount":"1796","inLanguage":"en","datePublished":"2023-01-13T12:47:29-05:00","dateModified":"2023-01-13T12:47:29-05:00","author":{"@type":"Person","name":"Prince Addo"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://127.0.0.1:3000/post/fts-vs-dirent-vs-ftw/"},"publisher":{"@type":"Organization","name":"Prince Addo's /blog","logo":{"@type":"ImageObject","url":"http://127.0.0.1:3000/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://127.0.0.1:3000 accesskey=h title="rince Addo's \blog (Alt + H)"><img src=http://127.0.0.1:3000/apple-touch-icon.png alt aria-label=logo height=35>rince Addo's \blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://127.0.0.1:3000/categories/ title=categories><span>categories</span></a></li><li><a href=http://127.0.0.1:3000/tags/ title=tags><span>tags</span></a></li><li><a href=http://www.princeaddo.com title=portfolio><span>portfolio</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://127.0.0.1:3000>Home</a>&nbsp;»&nbsp;<a href=http://127.0.0.1:3000/post/>Posts</a></div><h1 class=post-title>fts vs dirent vs ftw</h1><div class=post-description>A comparison on the fts.h, dirent.h, and ftw.h libraries</div><div class=post-meta><span title='2023-01-13 12:47:29 -0500 EST'>January 13, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;1796 words&nbsp;·&nbsp;Prince Addo&nbsp;|&nbsp;<a href=https://github.com/prince-ao/portfolio/tree/main/blog/content/post/fts-vs-dirent-vs-ftw.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#ftwh>ftw.h</a><ul><li><a href=#description>description</a></li><li><a href=#example>example</a></li><li><a href=#pros>pros</a></li><li><a href=#cons>cons</a></li></ul></li><li><a href=#direnth>dirent.h</a><ul><li><a href=#description-1>description</a></li><li><a href=#example-1>example</a></li><li><a href=#pros-1>pros</a></li><li><a href=#cons-1>cons</a></li></ul></li><li><a href=#ftsh>fts.h</a><ul><li><a href=#description-2>description</a></li><li><a href=#example-2>example</a></li><li><a href=#pros-2>pros</a></li><li><a href=#cons-2>cons</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div></details></div><div class=post-content><p>fts.h, dirent.h and ftw.h are distinct libraries, but what they all have in common
is that they can be used to do the important job of traversing the Linux
directory tree. In this article, the pros and cons of using one of these
libraries over the other will be weighed so you can make a more informed decision
when choosing one of these libraries.</p><hr><h2 id=ftwh>ftw.h<a hidden class=anchor aria-hidden=true href=#ftwh>#</a></h2><h3 id=description>description<a hidden class=anchor aria-hidden=true href=#description>#</a></h3><p>ftw.h is a library that defines two key functions:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;ftw.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>ftw</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dirpath</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fn</span><span class=p>)</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>fpath</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span> <span class=kt>int</span> <span class=n>typeflag</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>nopenfd</span>
</span></span><span class=line><span class=cl><span class=p>);</span> <span class=c1>// returns 0 on success, and -1 if an error occured.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>nftw</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>dirpath</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>fn</span><span class=p>)</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>fpath</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>stat</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>typeflag</span><span class=p>,</span> <span class=k>struct</span> <span class=n>FTW</span> <span class=o>*</span><span class=n>ftwbuf</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>nopenfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>flags</span>
</span></span><span class=line><span class=cl><span class=p>);</span> <span class=c1>// returns 0 on success, and -1 if an error occured.
</span></span></span></code></pre></div><p><code>ftw</code> was obsoleted by POSIX.1-2008, so we will not be discussing that function.
<code>nftw</code> is a function that walks through the entire directory tree, until the leaf,
using <strong>pre-order traversal</strong>(by default). The function takes in the path of the
where the function will start, <code>dirpath</code>, a function that matches the prototype,
<code>fn</code>, the number of file discriptors the function is allowed to have open at one
time, <code>nopenfd</code>, and optional flags, <code>flags</code>.</p><p>The user defined function input, <code>fn</code>, is what <code>nftw</code> will call every time it
reaches a new file in the directory tree. <code>fn</code> takes in as input a string
containing the path of the current file, fpath, a stat struct, <code>sb</code>,
flags, <code>typeflag</code>, and a FWT struct, <code>ftwbuf</code>. The stat struct is the same
that is returned by calling the <code>stat</code>function. It is defined as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>stat</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>dev_t</span>     <span class=n>st_dev</span><span class=p>;</span>     <span class=cm>/* ID of device containing file */</span>
</span></span><span class=line><span class=cl>    <span class=kt>ino_t</span>     <span class=n>st_ino</span><span class=p>;</span>     <span class=cm>/* inode number */</span>
</span></span><span class=line><span class=cl>    <span class=kt>mode_t</span>    <span class=n>st_mode</span><span class=p>;</span>    <span class=cm>/* protection */</span>
</span></span><span class=line><span class=cl>    <span class=kt>nlink_t</span>   <span class=n>st_nlink</span><span class=p>;</span>   <span class=cm>/* number of hard links */</span>
</span></span><span class=line><span class=cl>    <span class=kt>uid_t</span>     <span class=n>st_uid</span><span class=p>;</span>     <span class=cm>/* user ID of owner */</span>
</span></span><span class=line><span class=cl>    <span class=kt>gid_t</span>     <span class=n>st_gid</span><span class=p>;</span>     <span class=cm>/* group ID of owner */</span>
</span></span><span class=line><span class=cl>    <span class=kt>dev_t</span>     <span class=n>st_rdev</span><span class=p>;</span>    <span class=cm>/* device ID (if special file) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>off_t</span>     <span class=n>st_size</span><span class=p>;</span>    <span class=cm>/* total size, in bytes */</span>
</span></span><span class=line><span class=cl>    <span class=kt>blksize_t</span> <span class=n>st_blksize</span><span class=p>;</span> <span class=cm>/* blocksize for file system I/O */</span>
</span></span><span class=line><span class=cl>    <span class=kt>blkcnt_t</span>  <span class=n>st_blocks</span><span class=p>;</span>  <span class=cm>/* number of 512B blocks allocated */</span>
</span></span><span class=line><span class=cl>    <span class=kt>time_t</span>    <span class=n>st_atime</span><span class=p>;</span>   <span class=cm>/* time of last access */</span>
</span></span><span class=line><span class=cl>    <span class=kt>time_t</span>    <span class=n>st_mtime</span><span class=p>;</span>   <span class=cm>/* time of last modification */</span>
</span></span><span class=line><span class=cl>    <span class=kt>time_t</span>    <span class=n>st_ctime</span><span class=p>;</span>   <span class=cm>/* time of last status change */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p><code>typeflag</code> could be any one of these values:</p><p><strong>FTW_F</strong> := <code>fpath</code> is a regular file.</p><p><strong>FTW_D</strong> | <strong>FTW_DP</strong> := <code>fpath</code> is a directory.</p><p><strong>FTW_SL</strong> | <strong>FTW_SLN</strong> := <code>fpath</code> is a symbolic link.</p><p><strong>FTW_DNR</strong> := <code>fpath</code> is a directory which cannot be read.</p><p><strong>FTW_NS</strong> := The <code>stat</code> function call failed on <code>fpath</code>.</p><p><code>ftwbuf</code> is a FTW struct defined as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>FTW</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>base</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>level</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>where <code>base</code> is the offset of the filename in <code>fpath</code> and <code>level</code> is the depth of
<code>fpath</code> in the directory path, relative to the specified root, which has a level
of 0.</p><p>Two important <code>flags</code> that you should know about are</p><p><strong>FTW_DEPTH</strong> := when set, the function changes the traversal from pre-order to a <em>post-order traversal</em>.</p><p><strong>FTW_PHYS</strong> := when set, the function does not follow symbolic links when they are encountered.</p><p>For a more in-depth description of ftw.h read the
<a href=https://linux.die.net/man/3/ftw>man page</a>.</p><h3 id=example>example<a hidden class=anchor aria-hidden=true href=#example>#</a></h3><p>This is an example of using <code>nftw</code> to count the number of directories in the current
path.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;ftw.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>directoryN</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>directoryCounter</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>fpath</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>stat</span> <span class=o>*</span><span class=n>sb</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>typeflag</span><span class=p>,</span> <span class=k>struct</span> <span class=n>FTW</span> <span class=o>*</span><span class=n>ftwbuf</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>((</span><span class=n>typeflag</span> <span class=o>==</span> <span class=n>FTW_D</span> <span class=o>||</span> <span class=n>typeflag</span> <span class=o>==</span> <span class=n>FTW_DP</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=o>!</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>fpath</span><span class=p>,</span> <span class=s>&#34;.&#34;</span><span class=p>)</span> 
</span></span><span class=line><span class=cl>		<span class=o>&amp;&amp;</span> <span class=o>!</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>fpath</span><span class=p>,</span> <span class=s>&#34;..&#34;</span><span class=p>))</span> <span class=n>directoryN</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>flags</span> <span class=o>=</span> <span class=n>FTW_PHYS</span> <span class=o>|</span> <span class=n>FTW_DEPTH</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>(</span><span class=nf>nftw</span><span class=p>(</span><span class=s>&#34;.&#34;</span><span class=p>,</span> <span class=n>directoryCounter</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=n>flags</span><span class=p>)</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nf>perror</span><span class=p>(</span><span class=s>&#34;nftw&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;There are %u directories in the current directory</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>directoryN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=pros>pros<a hidden class=anchor aria-hidden=true href=#pros>#</a></h3><p>The biggest advantage of using <code>nftw</code> is its ease of use; with e simple function and a
couple of flags, you can have a Linux directory tree traverser up and running.
Another advantage is the simplicity. The <code>fn</code> function provides you with basically
all the detail about a particular file, so you can easily use that information to
make a decision. <strong>Overall, the ftw library allows you to easily develop a simple program
that traverses Linux directory tree.</strong></p><h3 id=cons>cons<a hidden class=anchor aria-hidden=true href=#cons>#</a></h3><p>The <code>nftw</code>, and especially the <code>ftw</code>, function is <strong>too simple for a more complex program</strong>.
For example, if you want to create a abstract representation of the Linux directory tree
in memory it will be, at least, non-trivial and probably impossible. This is because the
<code>nftw</code> function abstracts away the traversal and only offers a linear representation of
the it.</p><h2 id=direnth>dirent.h<a hidden class=anchor aria-hidden=true href=#direnth>#</a></h2><h3 id=description-1>description<a hidden class=anchor aria-hidden=true href=#description-1>#</a></h3><p>The key functions for dirent.h are:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dirent.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>DIR</span> <span class=o>*</span><span class=nf>opendir</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>name</span><span class=p>);</span> <span class=c1>// returns NULL if an error occurs and sets errno
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>DIR</span> <span class=o>*</span><span class=nf>fdopendir</span><span class=p>(</span><span class=kt>int</span> <span class=n>fd</span><span class=p>);</span> <span class=c1>// returns NULL if an error occurs and sets errno
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=nf>readdir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dirp</span><span class=p>);</span> <span class=c1>// returns NULL if an error occurs and sets errno
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>readdir_r</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dirp</span><span class=p>,</span> <span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=n>entry</span><span class=p>,</span> <span class=k>struct</span> <span class=n>dirent</span> <span class=o>**</span><span class=n>result</span><span class=p>);</span> <span class=c1>// returns 0 on success and a positive error number if an error occurs
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>seekdir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dirp</span><span class=p>,</span> <span class=kt>long</span> <span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>long</span> <span class=nf>telldir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dirp</span><span class=p>);</span> <span class=c1>// returns -1 on if an error occurs and sets errno
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>closedir</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>dirp</span><span class=p>);</span> <span class=c1>// returns 0 on success. On error, returns -1 and sets errno
</span></span></span></code></pre></div><p>The dirent library follows the familiar open, read, close pattern that is used in read
only files and the functions also match such purposes. <code>opendir</code> and <code>fdopendir</code> both
open a new <code>DIR</code>, they use the path of the root folder and the file file descriptor or
the directory, respectively. <code>DIR</code> is the central component of the dirent library.
Similar to <code>FILE</code>, you can read it by passing it to a function, but unlike <code>FILE</code> you
cannot write directly to it.</p><p>Both the <code>readdir</code> and <code>readdir_r</code> function read <code>DIR</code>;
the <code>readdir</code> function returns a dirent structure while the <code>readdir_r</code> takes in an
existing dirent structure, <code>entry</code>, and another dirent structure, <code>result</code> and stores
the current directory entry in <code>entry</code> and the next one in <code>result</code>.</p><p>Finally, <code>seekdir</code> and <code>telldir</code> are used to deposition <code>DIR</code> and <code>closedir</code> is used to
close it.</p><p>The dirent structure, the most important structure in the dirent structure, is described as</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>dirent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>ino_t</span>          <span class=n>d_ino</span><span class=p>;</span>       <span class=cm>/* inode number */</span>
</span></span><span class=line><span class=cl>    <span class=kt>off_t</span>          <span class=n>d_off</span><span class=p>;</span>       <span class=cm>/* offset to the next dirent */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>d_reclen</span><span class=p>;</span>    <span class=cm>/* length of this record */</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>char</span>  <span class=n>d_type</span><span class=p>;</span>      <span class=cm>/* type of file; not supported
</span></span></span><span class=line><span class=cl><span class=cm>                                   by all file system types */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>           <span class=n>d_name</span><span class=p>[</span><span class=mi>256</span><span class=p>];</span> <span class=cm>/* filename */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>For a more in-depth description of dirent.h read the <a href=https://github.com/tronkko/dirent/blob/master/include/dirent.h>source code</a>.</p><h3 id=example-1>example<a hidden class=anchor aria-hidden=true href=#example-1>#</a></h3><p>Another implementation of the number of directories in the current path.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;dirent.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>directoryN</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>directoryCounter</span><span class=p>(</span><span class=n>DIR</span> <span class=o>*</span><span class=n>root</span><span class=p>,</span> <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>root_path</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>struct</span> <span class=n>dirent</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>while</span><span class=p>((</span><span class=n>p</span> <span class=o>=</span> <span class=nf>readdir</span><span class=p>(</span><span class=n>root</span><span class=p>))</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=o>!</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>,</span> <span class=s>&#34;.&#34;</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=nf>strcmp</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>,</span> <span class=s>&#34;..&#34;</span><span class=p>))</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>d_type</span> <span class=o>==</span> <span class=n>DT_DIR</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=n>directoryN</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=kt>char</span> <span class=o>*</span><span class=n>full_path</span> <span class=o>=</span> <span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=nf>strlen</span><span class=p>(</span><span class=n>root_path</span><span class=p>)</span> <span class=o>+</span> <span class=nf>strlen</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=nf>strcpy</span><span class=p>(</span><span class=n>full_path</span><span class=p>,</span> <span class=n>root_path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=nf>strcat</span><span class=p>(</span><span class=n>full_path</span><span class=p>,</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>d_name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=nf>strcat</span><span class=p>(</span><span class=n>full_path</span><span class=p>,</span> <span class=s>&#34;/&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=n>DIR</span> <span class=o>*</span><span class=n>curr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span><span class=p>((</span><span class=n>curr</span> <span class=o>=</span> <span class=nf>opendir</span><span class=p>(</span><span class=n>full_path</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>				<span class=nf>perror</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>				<span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=nf>directroyCounter</span><span class=p>(</span><span class=n>curr</span><span class=p>,</span> <span class=n>full_path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>DIR</span> <span class=o>*</span><span class=n>curr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>root_path</span> <span class=o>=</span> <span class=s>&#34;./&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>((</span><span class=n>curr</span> <span class=o>=</span> <span class=nf>opendir</span><span class=p>(</span><span class=n>root_path</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=nf>perror</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>directoryCounter</span><span class=p>(</span><span class=n>curr</span><span class=p>,</span> <span class=n>root_path</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;There are %u directories in the current directory</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>directoryN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=pros-1>pros<a hidden class=anchor aria-hidden=true href=#pros-1>#</a></h3><p>dirent.h gives you more control over the method in which you execute the program. This
means that you can tailor the code to do what you need it to do and possibly achieve
a faster running time because of that. It also allows you to create more complex algorithm
by giving you the choice to go up or down the tree at any moment.</p><h3 id=cons-1>cons<a hidden class=anchor aria-hidden=true href=#cons-1>#</a></h3><p>The increased flexibility leads to increased complexity. Not only will you have to
execute several functions provided by dirent.h, but you will also have to use other
functions from other libraries(or even worst, make your own) to create a complete program.
This is due partly because the lack of information in the dirent structure.</p><h2 id=ftsh>fts.h<a hidden class=anchor aria-hidden=true href=#ftsh>#</a></h2><h3 id=description-2>description<a hidden class=anchor aria-hidden=true href=#description-2>#</a></h3><p>The key functions in fts.h are:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>FTS</span> <span class=o>*</span><span class=nf>fts_open</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span> <span class=k>const</span> <span class=o>*</span><span class=n>path_argv</span><span class=p>,</span> <span class=kt>int</span> <span class=n>options</span><span class=p>,</span>
</span></span><span class=line><span class=cl>              <span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=n>compar</span><span class=p>)(</span><span class=k>const</span> <span class=n>FTSENT</span> <span class=o>**</span><span class=p>,</span> <span class=k>const</span> <span class=n>FTSENT</span> <span class=o>**</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>FTSENT</span> <span class=o>*</span><span class=nf>fts_read</span><span class=p>(</span><span class=n>FTS</span> <span class=o>*</span><span class=n>ftsp</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fts_close</span><span class=p>(</span><span class=n>FTS</span> <span class=o>*</span><span class=n>ftsp</span><span class=p>);</span>
</span></span></code></pre></div><p>The <code>fts</code> library has similar interfaces as <code>dirent.h</code>. <code>fts_open</code> create a new <code>FTS</code>
which is analogous to <code>DIR</code>. <code>fts_read</code> reads the directory in preorder(by default)
or postorder depending on the <code>option</code> you gave to the <code>fts_open</code> function.</p><p>The <code>FTSENT</code> structure is what stores all the major information about a particular file.
The structure is described as:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_ftsent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>short</span> <span class=n>fts_info</span><span class=p>;</span>     <span class=cm>/* flags for FTSENT structure */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>          <span class=o>*</span><span class=n>fts_accpath</span><span class=p>;</span>  <span class=cm>/* access path */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>          <span class=o>*</span><span class=n>fts_path</span><span class=p>;</span>     <span class=cm>/* root path */</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span>          <span class=n>fts_pathlen</span><span class=p>;</span>  <span class=cm>/* strlen(fts_path) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span>          <span class=o>*</span><span class=n>fts_name</span><span class=p>;</span>     <span class=cm>/* filename */</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span>          <span class=n>fts_namelen</span><span class=p>;</span>  <span class=cm>/* strlen(fts_name) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span>          <span class=n>fts_level</span><span class=p>;</span>    <span class=cm>/* depth (-1 to N) */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>            <span class=n>fts_errno</span><span class=p>;</span>    <span class=cm>/* file errno */</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span>           <span class=n>fts_number</span><span class=p>;</span>   <span class=cm>/* local numeric value */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span>          <span class=o>*</span><span class=n>fts_pointer</span><span class=p>;</span>  <span class=cm>/* local address value */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>ftsent</span> <span class=o>*</span><span class=n>fts_parent</span><span class=p>;</span>   <span class=cm>/* parent directory */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>ftsent</span> <span class=o>*</span><span class=n>fts_link</span><span class=p>;</span>     <span class=cm>/* next file structure */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>ftsent</span> <span class=o>*</span><span class=n>fts_cycle</span><span class=p>;</span>    <span class=cm>/* cycle structure */</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>stat</span>   <span class=o>*</span><span class=n>fts_statp</span><span class=p>;</span>    <span class=cm>/* stat(2) information */</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>FTSENT</span><span class=p>;</span>
</span></span></code></pre></div><p>For more information on <code>fts.h</code> check out the <a href=https://linux.die.net/man/3/fts>man page</a></p><h3 id=example-2>example<a hidden class=anchor aria-hidden=true href=#example-2>#</a></h3><p>Yet another implementation of the number of directories in the current path.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;fts.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>directoryN</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>FTS</span> <span class=o>*</span><span class=n>op</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>FTSENT</span> <span class=o>*</span><span class=n>curr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=o>*</span><span class=n>root_path</span> <span class=o>=</span> <span class=p>{</span><span class=s>&#34;./&#34;</span><span class=p>,</span> <span class=nb>NULL</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span><span class=p>((</span><span class=n>op</span> <span class=o>=</span> <span class=nf>fts_open</span><span class=p>(</span><span class=n>root_path</span><span class=p>,</span> <span class=n>FTS_NOCHDIR</span> <span class=o>|</span> <span class=n>FTS_PHYSICAL</span> <span class=o>|</span> <span class=n>FTS_XDEV</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>))</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=nf>perror</span><span class=p>(</span><span class=s>&#34;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=nf>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>while</span><span class=p>((</span><span class=n>curr</span> <span class=o>=</span> <span class=nf>fts_read</span><span class=p>(</span><span class=n>op</span><span class=p>))</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=nf>S_ISDIR</span><span class=p>(</span><span class=n>curr</span><span class=o>-&gt;</span><span class=n>fts_statp</span><span class=o>-&gt;</span><span class=n>mode</span><span class=p>)){</span>
</span></span><span class=line><span class=cl>			<span class=n>directoryN</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>printf</span><span class=p>(</span><span class=s>&#34;There are %u directories in the current directory</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>directoryN</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=pros-2>pros<a hidden class=anchor aria-hidden=true href=#pros-2>#</a></h3><p><code>fts.h</code> allows you to create directory tree traversal quickly and <code>FTSENT</code> provides you
with a lot of useful information about the current file.</p><h3 id=cons-2>cons<a hidden class=anchor aria-hidden=true href=#cons-2>#</a></h3><p>The library is relatively obscure and at times hard to understand. It also suffers from
the same problem as <code>ftw.h</code>, namely, it is difficult to build more complex applications;
but my intuition tell me that <code>fts.h</code> allows more complexity than <code>ftw.h</code> because you&rsquo;re
looping while you read.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>After examining and experimenting with the various libraries, the choice between <code>fts.h</code>,
<code>dirent.h</code> and <code>ftw.h</code> depends on you&rsquo;re particular application and its complexity. For
example, if you&rsquo;re building a <code>ls(1)</code> clone, than either <code>ftw.h</code> or <code>fts.h</code> would be a
great choice because that command doesn&rsquo;t require any complicated traversal or to create
a another structure. If I were to list the libraries by order of how complex they allow
you to build you&rsquo;re application, it would be: <code>dirent.h</code>, <code>fts.h</code>, <code>ftw.h</code>; with <code>dirent.h</code>
allowing you to build the most complex applications.</p><p>So, if you&rsquo;re deciding which library to use, first think about how complex you&rsquo;re
application will be and how much control of the directory tree traversal you want,
and then make your choice. And if you want complete control, you can go as low as
using the <code>read</code> and <code>getdents</code> system calls.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://127.0.0.1:3000/tags/linux-programming/>linux-programming</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=http://127.0.0.1:3000>Prince Addo's /blog</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>